<h2 id="cs3601-lab2">CS3601-Lab2</h2>
<p>陈景韬</p>
<p>523030910028</p>
<h3 id="q1">Q1</h3>
<p><strong><em>练习题1-完成 kernel/mm/buddy.c 中的
split_chunk、merge_chunk、buddy_get_pages、 和 buddy_free_pages 函数中的
LAB 2 TODO 1 部分，其中 buddy_get_pages
用于分配指定阶大小的连续物理页，buddy_free_pages
用于释放已分配的连续物理页。</em></strong></p>
<p>split_chunk和merge_chunk都可以用递归的方法进行实现，注意merge_chunk的时候块的order不能超过MAX_ORDER</p>
<p>buddy_get_pages循环迭代找到free_list中能容纳的最小规模，且要求未被allocated，然后再split到合适的大小。</p>
<p>buddy_free_pages则是释放指定位置的块，后面再调用merge将可能的空闲块合并即可。</p>
<p>注意加上对空页的判别，不知道scores环节会不会特意传一个空的page。</p>
<h3 id="q2">Q2</h3>
<p><strong><em>练习题2-完成 kernel/mm/slab.c 中的
choose_new_current_slab、alloc_in_slab_impl 和 free_in_slab 函数中的 LAB
2 TODO 2 部分，其中 alloc_in_slab_impl 用于在 slab
分配器中分配指定阶大小的内存，而 free_in_slab
则用于释放上述已分配的内存。</em></strong></p>
<p>choose_new_current_slab
从pool中的partial_slab选一个slab来用，如果没有就返回NULL</p>
<p>alloc_in_slab_impl
从slab中找一个slot，如果满了就调用choose_new_current_slab再找一个新的slab</p>
<p>free_in_slab 将slab添加回free_list</p>
<h3 id="q3">Q3</h3>
<p>***练习题3-s完成 kernel/mm/kmalloc.c 中的 _kmalloc 函数中的 LAB 2
TODO 3 部分，在适当位置调用对应的函数，实现 kmalloc 功能***</p>
<p>size小的时候使用slab来分配，调用alloc_in_slab</p>
<p>size大的时候使用buddy_system来分配，调用get_pages()</p>
<h3 id="q4">Q4</h3>
<p><strong><em>练习题4-完成 kernel/arch/aarch64/mm/page_table.c 中的
query_in_pgtbl、map_range_in_pgtbl_common、unmap_range_in_pgtbl 和
mprotect_in_pgtbl 函数中的 LAB 2 TODO 4
部分，分别实现页表查询、映射、取消映射和修改页表权限的操作，以 4KB
页为粒度。</em></strong></p>
<p>query_in_pgtbl
逐级遍历列表，如果找不到条目就返回错误；中途额外处理大页的情况，直接返回所需的物理内存映射即可。如果正常找到最后一级页表，同样计算物理地址并返回entry。</p>
<p>map_range_in_pgtbl_common
批量映射一批连续的虚拟地址区间到物理内存空间，直接进到L3表，然后遍历空间并新建对应的条目，填写相关位数。</p>
<p>unmap_range_in_pgtbl
类似query_in_pgtbl中逐级遍历列表，但是注意当返回-ENOMAPPING的时候，说明此级页表下所有vm都未被映射，因此直接skip这一大段，不用unmap。如果正常到达末级页表，就逐项将其unmap，当前项用完或者total耗尽就停止。</p>
<p>mprotect_in_pgtbl
类似map_range_in_pgtbl直接进到末级表，然后逐项修改权限</p>
<h2 id="q5">Q5</h2>
<p><strong><em>思考题5-阅读 Arm Architecture Reference
Manual，思考要在操作系统中支持写时拷贝（Copy-on-Write，CoW）1需要配置页表描述符的哪个/哪些字段，并在发生页错误时如何处理。（在完成第三部分后，你也可以阅读页错误处理的相关代码，观察
ChCore 是如何支持 Cow 的）</em></strong></p>
<p>要配置AP(Access Permissions)，两位数分别定义el1和el0下的权限。</p>
<p>在发生页错误的时候，首先判断是否为CoW页面。如果是CoW，就分配一个新的物理页，并修改当前进程页表，建立对应vm-pm映射。然后恢复进程执行，完成操作。当然还要把对应结构体的AP改过来，不然下次还会报pagefault。
非CoW的话直接报错，终止进程。</p>
<h2 id="q6">Q6</h2>
<p><strong><em>思考题6-为了简单起见，在 ChCore 实验 Lab1
中没有为内核页表使用细粒度的映射，而是直接沿用了启动时的粗粒度页表，请思考这样做有什么问题。</em></strong></p>
<p>在权限管理方面会出问题，粗粒度的映射无法对小段内存进行精细的权限划分，进而导致安全问题，比如只读区域被映射到一个读写大页，导致内存的隔离安全被严重破坏；</p>
<p>同时也会导致大量的内存浪费，如果只需要映射少量的内容，粗粒度映射依然会为其分配大段内存，导致大量的内部碎片的产生。</p>
<h2 id="q8">Q8</h2>
<p><strong><em>完成 kernel/arch/aarch64/irq/pgfault.c 中的 do_page_fault
函数中的 LAB 2 TODO 5 部分，将缺页异常转发给 handle_trans_fault
函数。</em></strong></p>
<p>调用handle_trans_fault函数，传递当前进程的虚拟内存空间以及出错的地址，交给函数去补齐映射</p>
<h2 id="q9">Q9</h2>
<p><strong><em>练习题9-完成 kernel/mm/vmspace.c 中的 find_vmr_for_va
函数中的 LAB 2 TODO 6 部分，找到一个虚拟地址找在其虚拟地址空间中的
VMR。</em></strong></p>
<p>在红黑树上搜索，调用rb_search()，查找addr所属的区域，然后调用rb_entry()来得到所属的指针，返回对应的区间struct的指针。</p>
<h2 id="q10">Q10</h2>
<p><strong><em>练习题10-完成 kernel/mm/pgfault_handler.c 中的
handle_trans_fault 函数中的 LAB 2 TODO 7 部分（函数内共有 3
处填空，不要遗漏），实现 PMO_SHM 和 PMO_ANONYM
的按需物理页分配。你可以阅读代码注释，调用你之前见到过的相关函数来实现功能。</em></strong></p>
<p>在第一个blank处，调用virt_to_phys()将va转换成pa，然后用memset()把页空间清零。</p>
<p>在第二个blank处调用map_range_in_pgtbl()来建立映射，缺乏的rss参数一般用来进行内存占用统计，这里无关紧要，自定义一个占位用就可以。</p>
<p>在第三个blank处和第二个blank一样的调用map_range_in_pgtbl()，用于防止多进程映射中不同进程的冲突问题，再映射一遍可以防止映射丢失，且本身不会影响到正常进程中的运作。</p>
